#-------------------------------------------------------------------------------------
# DESCRIPTION:
#
#    To deal with high-resolution data, the globe is divided into blocks.
#
#     (180W,90N)                           (180E,90N)
#        .-----------------------------------.
#        |         |         |        |      |
#        |         |         |        |      |
#        |         |         |        |      |
#        .-----------------------------------.
#        |         |         |        |      |
#        |         |         |        |      |
#        |         |         |        |      |
#        .-----------------------------------.
#        |         |         |        |      |
#        |         |         |        |      |
#        |         |         |        |      |
#        .-----------------------------------.
#     (180W,90S)                           (180E,90S)
#   
#    1.
#    Boundaries for block (i,j) is saved in 
#    "gblock%lat_s(j), gblock%lat_n(j), gblock%lon_w(i), gblock%lon_e(i)" 
#    for south, north, west and east boundaries respectively.
#
#    2.
#    The (i,j) element of 2D array gblock%pio saves the global communication
#    number of process which is in charge of Input/Output of block (i,j).
#
#    3.
#    For Input/Output processes, "gblock%nblkme, gblock%xblkme(:), gblock%yblkme(:)"
#    save the locations of blocks which are handled by themselves.
#
#    4.
#    Division of blocks can be generated by number of blocks globally (by set_by_size), 
#    or set by predefined boundaries in files (by set_by_file).
# 
# Created by Shupeng Zhang, May 2023
#-------------------------------------------------------------------------------------
import CoLM_Utils
from CoLM_NetCDFSerial import NetCDFFile
from CoLM_Pixel import Pixel_type
import numpy as np
import os
import math
import sys

class Block_type(object):
    def __init__(self,nl_colm,MPI, SITE_lon_location,SITE_lat_location) -> None:
        self.MPI = MPI
        self.def_domain = nl_colm['DEF_domain']
        self.site_lon_location = SITE_lon_location
        self.site_lat_location = SITE_lat_location
        self.pixel = Pixel_type(MPI)
        self.pixel.set_edges(nl_colm['DEF_domain'].edges, nl_colm['DEF_domain'].edgen, nl_colm['DEF_domain'].edgew,
                             nl_colm['DEF_domain'].edgee)
        if os.path.exists(nl_colm['DEF_BlockInfoFile']):
            self.netfile = NetCDFFile(nl_colm['USEMPI'],nl_colm['DEF_BlockInfoFile'])
            self.netfile.ncio_read_bcast_serial()
            self.lat_s = self.netfile.ncio_read_bcast_serial ( 'lat_s' )
            self.lat_n = self.netfile.ncio_read_bcast_serial ( 'lat_n' )
            self.lon_w = self.netfile.ncio_read_bcast_serial ( 'lon_w' )
            self.lon_e = self.netfile.ncio_read_bcast_serial ( 'lon_e' )

            self.nyblk = len(self.lat_s)
            self.nxblk = len(self.lon_w)

            # blocks should be from south to north
            if self.lat_s[0] > self.lat_s[self.nyblk]:
                self.lat_s = self.lat_s[self.nyblk-1:0:-1]
                self.lat_n = self.lat_n[self.nyblk-1:0:-1]
        else:
            if nl_colm['DEF_AverageElementSize'] > 0:
                self.nxblk = math.floor(360./(nl_colm['DEF_AverageElementSize']/120.*50))
                self.nxblk = math.min(self.nxblk,360)
                while self.nxblk < 360 and 360 % self.nxblk != 0:
                    self.nxblk = self.nxblk + 1

                self.nyblk = math.floor(180./(nl_colm['DEF_AverageElementSize']/120.*50))
                self.nyblk = min(self.nxblk,180)
                while (self.nyblk < 180) and 180 % self.nyblk != 0:
                    self.nyblk = self.nyblk + 1
            else:
                self.nxblk = nl_colm['DEF_nx_blocks']
                self.nyblk = nl_colm['DEF_ny_blocks']
            
            
            if 360 % nl_colm['DEF_nx_blocks'] != 0 or 180 % nl_colm['DEF_ny_blocks'] != 0:
                if MPI.p_is_master:
                    print( 'Number of blocks in longitude should be a factor of 360 ' )
                    print( ' and Number of blocks in latitude should be a factor of 180.') 
                    MPI.CoLM_stop ()

            self.lon_w = np.zeros(self.nxblk)
            self.lon_e = np.zeros(self.nxblk)
        
            for iblk in range(self.nxblk):
                self.lon_w[iblk] = -180.0 + 360.0/self.nxblk * iblk 
                self.lon_e[iblk] = -180.0 + 360.0/self.nxblk * (iblk+1)

                CoLM_Utils. normalize_longitude (self.lon_w[iblk])
                CoLM_Utils. normalize_longitude (self.lon_e[iblk])
            
            self.lat_s = np.zeros(self.nyblk)
            self.lat_n = np.zeros(self.nyblk)

            for jblk in range(self.nyblk):
                self.lat_s[jblk] = -90.0 + 180.0/self.nyblk * jblk
                self.lat_n[jblk] = -90.0 + 180.0/self.nyblk * jblk + 1

            if self.MPI.p_is_master:
                print ( 'Block information:')
                print ( str(self.nxblk)+' blocks in longitude,'+ str(self.nyblk)+ ' blocks in latitude.')
            self.nl_colm = nl_colm
            self.init_pio ()

    def clip (self, iblk_south, iblk_north, iblk_west, iblk_east, numblocks):
        edges = self.def_domain.edges
        edgen = self.def_domain.edgen
        edgew = self.def_domain.edgew
        edgee = self.def_domain.edgee
        # print(self.nyblk, self.lat_s)
        # print('-------------------+++++++++++')

        iblk_south = CoLM_Utils.find_nearest_south (edges, self.nyblk, self.lat_s)
        iblk_north = CoLM_Utils.find_nearest_north (edgen, self.nyblk, self.lat_n)

        edgew = CoLM_Utils.  normalize_longitude (edgew)
        edgee = CoLM_Utils.  normalize_longitude (edgee)

        if edgew == edgee:
            iblk_west = 1
            iblk_east = self.nxblk
        else:
            iblk_west = CoLM_Utils.find_nearest_west (edgew, self.nxblk, self.lon_w)
            iblk_east = CoLM_Utils.find_nearest_east (edgee, self.nxblk, self.lon_e)

            if iblk_west == iblk_east:
                if CoLM_Utils.lon_between_floor(edgee,self.lon_w[iblk_west],edgew):
                    iblk_west = 1
                    iblk_east = self.nxblk

        if numblocks is not None:
            numblocks_y = iblk_north - iblk_south + 1
            
            if iblk_east >= iblk_west :
                numblocks_x = iblk_east - iblk_west + 1
            else:
                numblocks_x = self.nxblk - iblk_west + 1 + iblk_east

            numblocks = numblocks_x * numblocks_y
        return iblk_south, iblk_north, iblk_west, iblk_east,numblocks

    def init_pio (self):
        iblk_south = 1
        iblk_north  = 1
        iblk_west = 1
        iblk_east = 1
        numblocks = 1
        if self.MPI.p_is_master:
            iblk_south, iblk_north, iblk_west, iblk_east,numblocks = self.clip (iblk_south, iblk_north, iblk_west, iblk_east, numblocks)
      
        if self.nl_colm['USEMPI']:
            # NetCDFFile.mpi_bcast (numblocks, 1, MPI_INTEGER, p_root, p_comm_glb, p_err)
            self.MPI.divide_processes_into_groups (numblocks, self.DEF_PIO_groupsize)

        self.pio = np.zeros((self.nxblk,self.nyblk))

        if self.MPI.p_is_master:
        
            self.pio[:,:] = -1

            iproc = -1
            for jblk in range( iblk_south,iblk_north):
                iblk = iblk_west
                while True:
                    if self.nl_colm['USEMPI']:
                        iproc = (iproc+1 )% self.MPI.p_np_io
                        self.pio[iblk-1,jblk-1] = self.MPI.p_address_io[iproc]
                    else:
                        self.pio[iblk-1,jblk-1] = self.MPI.p_root
                        

                    if iblk != iblk_east:
                        iblk = iblk % self.nxblk + 1
                    else:
                        break

            if self.nl_colm['USEMPI']:
        # NetCDFFile.mpi_bcast (self.pio, self.nxblk * self.nyblk, MPI_INTEGER, p_root, p_comm_glb, p_err)
                pass

            if self.nl_colm['SinglePoint']:
                self.nblkme = 0
                if self.MPI.p_is_io:
                    self.nblkme = len(np.where(self.pio==self.MPI.p_iam_glb)[0])
                    if self.nblkme > 0:
                        iblkme = 0
                        self.xblkme = np.zeros(self.nblkme)
                        self.yblkme = np.zeros(self.nblkme)
                        for iblk in range( self.nxblk):
                            for jblk in range(self.nyblk):
                                if self.MPI.p_iam_glb == self.pio[iblk,jblk]:
                                    iblkme = iblkme
                                    self.xblkme[iblkme] = iblk
                                    self.yblkme[iblkme] = jblk
            else:
                self.nblkme = 1
                self.xblkme = np.zeros(1)
                self.yblkme = np.zeros(1)
                CoLM_Utils. normalize_longitude (self.site_lon_location)
                self.xblkme[0] = CoLM_Utils.find_nearest_west  (self.site_lon_location, self.nxblk, self.lon_w)
                self.yblkme[0] = CoLM_Utils.find_nearest_south (self.site_lat_location, self.nyblk, self.lat_s)

    def assimilate_gblock(self):
        self.pixel.assimilate_gblock(self.nyblk, self.lat_s, self.lat_n,
                                self.nxblk, self.lon_w, self.lon_e)
    
    def save_to_file (self, dir_landdata):
        if self.MPI.p_is_master:
            filename = os.path.join(dir_landdata ,'block.nc')
    
            plat_system = sys.platform
            if 'win' in plat_system:
                filename = dir_landdata + '\\'+ 'block.nc'

            netfile = NetCDFFile(self.MPI)


            netfile.ncio_create_file (filename)

            netfile.ncio_define_dimension ( 'longitude', self.nxblk)
            netfile.ncio_define_dimension ( 'latitude',  self.nyblk)

            netfile.ncio_write_serial ( 'lat_s', self.lat_s, 'latitude' )
            netfile.ncio_write_serial ( 'lat_n', self.lat_n, 'latitude' )
            netfile.ncio_write_serial ( 'lon_w', self.lon_w, 'longitude')
            netfile.ncio_write_serial ( 'lon_e', self.lon_e, 'longitude')

    def get_blockname(self, iblk, jblk):
        if self.lat_s[jblk] < 0:
            cy = 's' + str(-int(self.lat_s[jblk]))
        else:
            cy = 'n' + str(int(self.lat_s[jblk]))

        if self.lon_w[iblk] < 0:
            cx = 'w' + str(-int(self.lon_w[iblk]))
        else:
            cx = 'e' + str(int(self.lon_w[iblk]))

        blockname = cx + '_' + cy

        return blockname

    def get_filename_block(self, filename, iblk, jblk):
        blockname = self.get_blockname(iblk, jblk)
        i = len(filename.strip())
        while i > 0:
            if filename[i - 1, i - 1] == '.':
                break
            i -= 1

        if i > 0:
            fileblock = filename[:i - 1] + '_' + blockname + '.nc'
        else:
            fileblock = filename + '_' + blockname + '.nc'

        return fileblock


